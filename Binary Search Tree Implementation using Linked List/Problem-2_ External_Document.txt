

Overview
--------

This program performs the following operation
  * Add a Key<String> to a hierarchy of list:

	- We Start Adding the key to the lowermost level, once added we check for the availability for any level above the current level.
	- We Flip the Coin until the point where you reach the topmost level and key is the only element available on the list.
	- Flipping the coin generates either 0 or 1, 
	- if 1 is returned from coin flip, add the element to the upper level.
		- Check if you are at the topmost level, with the just key in the list. - Stop the flip and exit.
		- If Not, keep flipping the coin.
	- if 0 is returned don't add it to the upper level. Don't flip the coin further and exit.

  * Searching for the Key< String> in the hierarchy of the list:
	
	- Uppermost list in the set contains the least element and the lowermost contains all the Element.
	- To search any element say "orange" we start searching for the element availability in the topmost list (say contains "dates" "Nachos" and "Salt" here),
	- If found- don't proceed further. Return true.
	- If not found, get to know the range of elements in topmost level within which the element could have been there(in this case between "Nachos" and "Salt").
	- We follow the link of the range of elements found to the lowest level. This Narrows down our search range.
	- We continue the search until the element is found or we reach the Lowermost level.
	- If the search is being made at the lowermost level also and the key couldn't be found. Return False.


The solution delivered is based on several important factors as the implementation of data structure both at the individual level and hierarchy level.


Files and external data
-----------------------

Below is the main java files:

  - SkipUI.java  -- main for the program that prompts the user for input in form of the command, in return creating coin type and calling the method from ListHierarcy.

Below is the Implementation Java file:

  - ListHierarcy.java -- class that contains the functionality of adding and searching the key at the DataStructure.

Three java files are implementing the Data Structure i.e Linked List of Linked List.

  - Node.java -- Implements a basic node structure with data attribute and multiple reference attribute.
  - LinkedList.java -- Implement the Linked List to contain elements on each level, with each element as a node.
  - SetofLinkedList.java -- Implements the Linked List to store all the levels<LinkedList> into one Linked List where the New Level<Node> always getting added as a head element.


Below is the file to define Coin:

  - Coin.java - Interface, declaring the method "flip".
  - ArrayCoin.java - Class to implement a coin interface and provides its implementation for the "flip" method based on the value stored in an array.
  - Random.java - Class to implement a coin interface and provides its implementation for the "flip" method based on random value generated.


Data structures and their relations to each other
-------------------------------------------------

The program read the data available in the file into different user-defined data structure object that is

  - Node -- Class to implement a structure for creating a space to store the element and provide a reference of the neighboring node(next and previous) in the list.
	    Reference to the node containing the same element on nest upper or nest lower level is also maintained.

  - LinkedList - Uses the Node class to implement each node. Each Node will point to the previous and next elements.
		 The node will also have reference to the node containing the element available in the next upper or next lower list.
		 
		--

  - SetofLinkedList - It implements Linked list data structure to contain each individual Linked List as node pointing to the previous and next level. 
	       	      It is having method: Add, getHead(),setHead(), getList(int index) and toString().

Assumptions
-----------

  - The key element we will get to add will be in the form of String.
  - No Key element(string) provided to the store will be more than 15 characters.  
 

Key algorithms and design elements
----------------------------------

Adding the New key: This Method would add the key passed in the list hierarchy if already not available.
		     - First, it calls the search method to check if the element is available or not.
			- Search returns either true(if found) or false(if not found).
			- while search as we traverse down the list till the lowermost list, 
		          we narrow down our range of elements (basically to two elements at the lowermost level)between which the new key would fall.
		     - using the key and range we directly place the element between the range.

		     - One the key is added to the lowermost element, we check for the availability for any level above the current level.
			- We Flip the Coin until the point where you reach the topmost level and key is the only element available on the list.
			- Flipping the coin generates either 0 or 1, 
			- if 1 is returned from the coin flip, add the element to the upper level.
				- Check if you are at the topmost level, with the just key in the list. - Stop the flip and exit.
				- If Not, keep flipping the coin.
			- if 0 is returned don't add it to an upper level. Don't flip the coin further and exit.

Searching the key: This method is for searching the element provided by performing the below algorithm
		    - To search any element say "orange" we start searching for the element availability in the topmost list (say contains "dates" "Nachos" and "Salt" here),
		    - If found- don't proceed further. Return true.
		    - If not found, get to know the range of elements in topmost level within which the element could have been there(in this case between "Nachos" and "Salt").
		    - We follow the link of range of element found to the next lower level. This Narrows down our search range.
		    - We continue the search until the element is found or we reach the Lowermost level.
		    - if the search is completed at the lowermost level also and the key couldn't be found. Return False.



Limitations
-----------

The current design is limited to only two operations adding and searching the Key.
It doesn't have the implementation for another operation that could be performed on the hierarchy e.g Remove.
